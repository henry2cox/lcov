#!/usr/bin/env perl
#
#   Copyright (c) International Business Machines  Corp., 2002,2012
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or (at
#   your option) any later version.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#   General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, see
#   <http://www.gnu.org/licenses/>.
#
#
# lcov
#
#   This is a wrapper script which provides a single interface for accessing
#   LCOV coverage data.
#
#
# History:
#   2002-08-29 created by Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
#                         IBM Lab Boeblingen
#   2002-09-05 / Peter Oberparleiter: implemented --kernel-directory +
#                multiple directories
#   2002-10-16 / Peter Oberparleiter: implemented --add-tracefile option
#   2002-10-17 / Peter Oberparleiter: implemented --extract option
#   2002-11-04 / Peter Oberparleiter: implemented --list option
#   2003-03-07 / Paul Larson: Changed to make it work with the latest gcov
#                kernel patch.  This will break it with older gcov-kernel
#                patches unless you change the value of $gcovmod in this script
#   2003-04-07 / Peter Oberparleiter: fixed bug which resulted in an error
#                when trying to combine .info files containing data without
#                a test name
#   2003-04-10 / Peter Oberparleiter: extended Paul's change so that LCOV
#                works both with the new and the old gcov-kernel patch
#   2003-04-10 / Peter Oberparleiter: added $gcov_dir constant in anticipation
#                of a possible move of the gcov kernel directory to another
#                file system in a future version of the gcov-kernel patch
#   2003-04-15 / Paul Larson: make info write to STDERR, not STDOUT
#   2003-04-15 / Paul Larson: added --remove option
#   2003-04-30 / Peter Oberparleiter: renamed --reset to --zerocounters
#                to remove naming ambiguity with --remove
#   2003-04-30 / Peter Oberparleiter: adjusted help text to include --remove
#   2003-06-27 / Peter Oberparleiter: implemented --diff
#   2003-07-03 / Peter Oberparleiter: added line checksum support, added
#                --no-checksum
#   2003-12-11 / Laurent Deniel: added --follow option
#   2004-03-29 / Peter Oberparleiter: modified --diff option to better cope with
#                ambiguous patch file entries, modified --capture option to use
#                modprobe before insmod (needed for 2.6)
#   2004-03-30 / Peter Oberparleiter: added --path option
#   2004-08-09 / Peter Oberparleiter: added configuration file support
#   2008-08-13 / Peter Oberparleiter: added function coverage support
#   2020-09-15 / Henry Cox:  refactor to use common utilities.
#

use strict;
use warnings;
use File::Basename;
use File::Path;
use File::Find;
use File::Temp qw /tempdir/;
use File::Spec::Functions qw /abs2rel canonpath catdir catfile catpath
			      file_name_is_absolute rootdir splitdir splitpath/;
use Getopt::Long;
use Cwd qw /abs_path getcwd/;
use FindBin;

use lib "$FindBin::Bin/../lib";
use lcovutil qw ($tool_name $quiet
                 define_errors parse_ignore_errors ignorable_error
                 info set_info_callback verbose $verbose
                 debug $debug
                 die_handler warn_handler abort_handler
                 append_tempdir temp_cleanup
                 parse_cov_filters summarize_cov_filters
                 $FILTER_BRANCH_NO_COND $FILTER_LINE_CLOSE_BRACE @cov_filter
                 filterStringsAndComments simplifyCode balancedParens

                 %geninfoErrs $ERROR_GCOV $ERROR_SOURCE $ERROR_MISMATCH
                 $ERROR_BRANCH $ERROR_EMPTY $ERROR_FORMAT
                 is_external $opt_no_external @internal_dirs
                 system_no_output
                 rate get_overall_line

                 %opt_rc apply_rc_params
                 strip_directories transform_pattern
  );


# Global constants
our $tool_dir		= abs_path(dirname($0));
our $lcov_version	= 'LCOV version '.`$tool_dir/get_version.sh --full`;
our $lcov_url		= "http://ltp.sourceforge.net/coverage/lcov.php";
$tool_name = basename($0); # defined in lcovutil module

# Directory containing gcov kernel files
our $gcov_dir;

# Where to create temporary directories
our $tmp_dir;

# Internal constants
our $GKV_PROC = 0;	# gcov-kernel data in /proc via external patch
our $GKV_SYS = 1;	# gcov-kernel data in /sys via vanilla 2.6.31+
our @GKV_NAME = ( "external", "upstream" );
our $pkg_gkv_file = ".gcov_kernel_version";
our $pkg_build_file = ".build_directory";

# Branch data combination types
our $BR_SUB = 0;
our $BR_ADD = 1;

lcovutil::define_errors(\%lcovutil::geninfoErrs);

$ERROR_MISMATCH   = scalar(keys(%lcovutil::geninfoErrs));
$ERROR_BRANCH     = $ERROR_MISMATCH + 1;
# errors unique to 'lcov':
$ERROR_EMPTY      = $ERROR_BRANCH + 1;
our %lcovErrs = (
  "empty"    => $ERROR_EMPTY,
  "mismatch" => $ERROR_MISMATCH,
  "branch"   => $ERROR_BRANCH,
);
lcovutil::define_errors(\%lcovErrs);

# Prototypes
sub print_usage(*);
sub check_options();
sub userspace_reset();
sub userspace_capture();
sub kernel_reset();
sub kernel_capture();
sub kernel_capture_initial();
sub package_capture();
sub add_traces();
sub extract();
sub remove();
sub list();
sub get_common_filename($$);
sub read_diff($);
sub diff();
sub system_no_output($@);
sub my_info(@);
set_info_callback(\&my_info);
sub create_temp_dir();
sub setup_gkv();
sub print_overall_rate($$$$$$$$$);
sub lcov_geninfo(@);
sub create_package($$$;$);
sub summary();

# Global variables & initialization
our @directory;	 # Specifies where to get coverage data from
our @kernel_directory;  # If set, captures only from specified kernel subdirs
our @add_tracefile;     # If set, reads in and combines all files in list
our $list;	      # If set, list contents of tracefile
our $extract;	   # If set, extracts parts of tracefile
our $remove;	    # If set, removes parts of tracefile
our $diff;	      # If set, modifies tracefile according to diff
our $reset;	     # If set, reset all coverage data to zero
our $capture;	   # If set, capture data
our $output_filename;   # Name for file to write coverage data to
our $test_name = "";    # Test case name
our $help;	      # Help option flag
our $version;	   # Version option flag
our $convert_filenames; # If set, convert filenames when applying diff
our $strip;	     # If set, strip leading directories when applying diff
our $temp_dir_name;     # Name of temporary directory
our $cwd = `pwd`;       # Current working directory
our $data_stdout;       # If set, indicates that data is written to stdout
our $follow;	    # If set, indicates that find shall follow links
our $diff_path = "";    # Path removed from tracefile when applying diff
our $base_directory;    # Base directory (cwd of gcc during compilation)
our $checksum;	  # If set, calculate a checksum for each line
our $no_checksum;       # If set, don't calculate a checksum for each line
our $compat_libtool;    # If set, indicates that libtool mode is to be enabled
our $no_compat_libtool; # If set, indicates that libtool mode is to be disabled
our $gcov_tool;
our @opt_ignore_errors;
our @opt_filter;
our $initial;
our @include_patterns; # List of source file patterns to include
our @exclude_patterns; # List of source file patterns to exclude
our $no_recursion = 0;
our $to_package;
our $from_package;
our $maxdepth;
our $no_markers;
chomp($cwd);
our $gcov_gkv;	  # gcov kernel support version found on machine
our $opt_derive_func_data;
our $opt_list_full_path;
our $opt_no_list_full_path;
our $opt_list_width = 80;
our $opt_list_truncate_max = 20;
our $opt_external;
our $opt_config_file;
our @opt_summary;
our $opt_compat;
our $ln_overall_found;
our $ln_overall_hit;
our $fn_overall_found;
our $fn_overall_hit;
our $br_overall_found;
our $br_overall_hit;
our $func_coverage = 1;
our $br_coverage = 0;


#
# Code entry point
#

$SIG{__WARN__} = \&lcovutil::warn_handler;
$SIG{__DIE__} = \&lcovutil::die_handler;
$SIG{'INT'} = \&lcovutil::abort_handler;
$SIG{'QUIT'} = \&lcovutil::abort_handler;

# Check command line for a configuration file name
Getopt::Long::Configure("pass_through", "no_auto_abbrev");
GetOptions("config-file=s" => \$opt_config_file,
	   "rc=s%" => \%opt_rc);
Getopt::Long::Configure("default");

lcovutil::apply_rc_params($opt_config_file,
			  { "lcov_gcov_dir"	     => \$gcov_dir,
			    "lcov_tmp_dir"	     => \$tmp_dir,
			    "lcov_list_full_path"    => \$opt_list_full_path,
			    "lcov_list_width"	     => \$opt_list_width,
			    "lcov_list_truncate_max" => \$opt_list_truncate_max,
			    "lcov_branch_coverage"   => \$br_coverage,
			    "lcov_function_coverage" => \$func_coverage,
			  });

# Parse command line options
if (!GetOptions("directory|d|di=s" => \@directory,
		"add-tracefile|a=s" => \@add_tracefile,
		"list|l=s" => \$list,
		"kernel-directory|k=s" => \@kernel_directory,
		"extract|e=s" => \$extract,
		"remove|r=s" => \$remove,
		"diff=s" => \$diff,
		"convert-filenames" => \$convert_filenames,
		"strip=i" => \$strip,
		"capture|c" => \$capture,
		"output-file|o=s" => \$output_filename,
		"test-name|t=s" => \$test_name,
		"zerocounters|z" => \$reset,
		"quiet|q" => \$lcovutil::quiet,
		"verbose|v" => \$lcovutil::verbose,
		"help|h|?" => \$help,
		"version|v" => \$version,
		"follow|f" => \$follow,
		"path=s" => \$diff_path,
		"base-directory|b=s" => \$base_directory,
		"checksum" => \$checksum,
		"no-checksum" => \$no_checksum,
		"compat-libtool" => \$compat_libtool,
		"no-compat-libtool" => \$no_compat_libtool,
		"gcov-tool=s" => \$gcov_tool,
		"ignore-errors=s" => \@opt_ignore_errors,
		"filter=s" => \@opt_filter,
		"initial|i" => \$initial,
		"include=s" => \@include_patterns,
		"exclude=s" => \@exclude_patterns,
		"no-recursion" => \$no_recursion,
		"to-package=s" => \$to_package,
		"from-package=s" => \$from_package,
		"no-markers" => \$no_markers,
		"derive-func-data" => \$opt_derive_func_data,
		"debug" => \$lcovutil::debug,
		"list-full-path" => \$opt_list_full_path,
		"no-list-full-path" => \$opt_no_list_full_path,
		"external" => \$opt_external,
		"no-external" => \$lcovutil::opt_no_external,
		"summary=s" => \@opt_summary,
		"compat=s" => \$opt_compat,
		"config-file=s" => \$opt_config_file,
		"rc=s%" => \%opt_rc,
		))
{
	print(STDERR "Use $tool_name --help to get usage information\n");
	exit(1);
}
else
{
	# Merge options
	if (defined($no_checksum))
	{
		$checksum = ($no_checksum ? 0 : 1);
		$no_checksum = undef;
	}

	if (defined($no_compat_libtool))
	{
		$compat_libtool = ($no_compat_libtool ? 0 : 1);
		$no_compat_libtool = undef;
	}

	if (defined($opt_no_list_full_path))
	{
		$opt_list_full_path = ($opt_no_list_full_path ? 0 : 1);
		$opt_no_list_full_path = undef;
	}

	push(@lcovutil::internal_dirs, $base_directory)
	  if defined($base_directory);
	if (defined($opt_external)) {
		$lcovutil::opt_no_external = 0;
		$opt_external = undef;
	}
}

# Check for help option
if ($help)
{
	print_usage(*STDOUT);
	exit(0);
}

# Check for version option
if ($version)
{
	print("$tool_name: $lcov_version\n");
	exit(0);
}
lcovutil::parse_ignore_errors(@opt_ignore_errors);
# Determine what coverpoints the user wants to filter
parse_cov_filters(@opt_filter);

# Check list width option
if ($opt_list_width <= 40) {
	die("ERROR: lcov_list_width parameter out of range (needs to be ".
	    "larger than 40)\n");
}

# Normalize --path text
$diff_path =~ s/\/$//;

if ($follow)
{
	$follow = "-follow";
}
else
{
	$follow = "";
}

if ($no_recursion)
{
	$maxdepth = "-maxdepth 1";
}
else
{
	$maxdepth = "";
}

# Check for valid options
check_options();

# Only --extract, --remove and --diff allow unnamed parameters
if (@ARGV && !($extract || $remove || $diff || @opt_summary))
{
	die("Extra parameter found: '".join(" ", @ARGV)."'\n".
	    "Use $tool_name --help to get usage information\n");
}

# Check for output filename
$data_stdout = !($output_filename && ($output_filename ne "-"));

if ($capture)
{
	if ($data_stdout)
	{
		# Option that tells geninfo to write to stdout
		$output_filename = "-";
	}
}

# Determine kernel directory for gcov data
if (!$from_package && !@directory && ($capture || $reset)) {
	($gcov_gkv, $gcov_dir) = setup_gkv();
}

# Check for requested functionality
if ($reset)
{
	$data_stdout = 0;
	# Differentiate between user space and kernel reset
	if (@directory)
	{
		userspace_reset();
	}
	else
	{
		kernel_reset();
	}
}
elsif ($capture)
{
	# Capture source can be user space, kernel or package
	if ($from_package) {
		package_capture();
	} elsif (@directory) {
		userspace_capture();
	} else {
		if ($initial) {
			if (defined($to_package)) {
				die("ERROR: --initial cannot be used together ".
				    "with --to-package\n");
			}
			kernel_capture_initial();
		} else {
			kernel_capture();
		}
	}
}
elsif (@add_tracefile)
{
	($ln_overall_found, $ln_overall_hit,
	 $fn_overall_found, $fn_overall_hit,
	 $br_overall_found, $br_overall_hit) = add_traces();
}
elsif ($remove)
{
	($ln_overall_found, $ln_overall_hit,
	 $fn_overall_found, $fn_overall_hit,
	 $br_overall_found, $br_overall_hit) = remove();
}
elsif ($extract)
{
	($ln_overall_found, $ln_overall_hit,
	 $fn_overall_found, $fn_overall_hit,
	 $br_overall_found, $br_overall_hit) = extract();
}
elsif ($list)
{
	$data_stdout = 0;
	list();
}
elsif ($diff)
{
	if (scalar(@ARGV) != 1)
	{
		die("ERROR: option --diff requires one additional argument!\n".
		    "Use $tool_name --help to get usage information\n");
	}
	($ln_overall_found, $ln_overall_hit,
	 $fn_overall_found, $fn_overall_hit,
	 $br_overall_found, $br_overall_hit) = diff();
}
elsif (@opt_summary)
{
	$data_stdout = 0;
	($ln_overall_found, $ln_overall_hit,
	 $fn_overall_found, $fn_overall_hit,
	 $br_overall_found, $br_overall_hit) = summary();
}

temp_cleanup();

if (defined($ln_overall_found)) {
	print_overall_rate(1, $ln_overall_found, $ln_overall_hit,
			   1, $fn_overall_found, $fn_overall_hit,
			   1, $br_overall_found, $br_overall_hit);
} else {
	info("Done.\n") if (!$list && !$capture);
}
summarize_cov_filters();
exit(0);

#
# print_usage(handle)
#
# Print usage information.
#

sub print_usage(*)
{
	local *HANDLE = $_[0];

	print(HANDLE <<END_OF_USAGE);
Usage: $tool_name [OPTIONS]

Use lcov to collect coverage data from either the currently running Linux
kernel or from a user space application. Specify the --directory option to
get coverage data for a user space program.

Misc:
  -h, --help                      Print this help, then exit
  -v, --version                   Print version number, then exit
  -q, --quiet                     Do not print progress messages

Operation:
  -z, --zerocounters              Reset all execution counts to zero
  -c, --capture                   Capture coverage data
  -a, --add-tracefile FILE        Add contents of tracefiles
  -e, --extract FILE PATTERN      Extract files matching PATTERN from FILE
  -r, --remove FILE PATTERN       Remove files matching PATTERN from FILE
  -l, --list FILE                 List contents of tracefile FILE
      --diff FILE DIFF            Transform tracefile FILE according to DIFF
      --summary FILE              Show summary coverage data for tracefiles

Options:
  -i, --initial                   Capture initial zero coverage data
  -t, --test-name NAME            Specify test name to be stored with data
  -o, --output-file FILENAME      Write data to FILENAME instead of stdout
  -d, --directory DIR             Use .da files in DIR instead of kernel
  -f, --follow                    Follow links when searching .da files
  -k, --kernel-directory KDIR     Capture kernel coverage data only from KDIR
  -b, --base-directory DIR        Use DIR as base directory for relative paths
      --convert-filenames         Convert filenames when applying diff
      --strip DEPTH               Strip initial DEPTH directory levels in diff
      --path PATH                 Strip PATH from tracefile when applying diff
      --(no-)checksum             Enable (disable) line checksumming
      --(no-)compat-libtool       Enable (disable) libtool compatibility mode
      --gcov-tool TOOL            Specify gcov tool location
      --ignore-errors ERRORS      Continue after ERRORS (gcov, source, graph)
      --filter TYPE               Ignore coverpoints of TYPE (branch, line)
      --no-recursion              Exclude subdirectories from processing
      --to-package FILENAME       Store unprocessed coverage data in FILENAME
      --from-package FILENAME     Capture from unprocessed data in FILENAME
      --no-markers                Ignore exclusion markers in source code
      --derive-func-data          Generate function data from line data
      --list-full-path            Print full path during a list operation
      --(no-)external             Include (ignore) data for external files
      --config-file FILENAME      Specify configuration file location
      --rc SETTING=VALUE          Override configuration file setting
      --compat MODE=on|off|auto   Set compat MODE (libtool, hammer, split_crc)
      --include PATTERN           Include files matching PATTERN
      --exclude PATTERN           Exclude files matching PATTERN

For more information see: $lcov_url
END_OF_USAGE
	;
}


#
# check_options()
#
# Check for valid combination of command line options. Die on error.
#

sub check_options()
{
	my $i = 0;

	# Count occurrence of mutually exclusive options
	$reset && $i++;
	$capture && $i++;
	@add_tracefile && $i++;
	$extract && $i++;
	$remove && $i++;
	$list && $i++;
	$diff && $i++;
	@opt_summary && $i++;

	if ($i == 0)
	{
		die("Need one of options -z, -c, -a, -e, -r, -l, ".
		    "--diff or --summary\n".
		    "Use $tool_name --help to get usage information\n");
	}
	elsif ($i > 1)
	{
		die("ERROR: only one of -z, -c, -a, -e, -r, -l, ".
		    "--diff or --summary allowed!\n".
		    "Use $tool_name --help to get usage information\n");
	}
}


#
# userspace_reset()
#
# Reset coverage data found in DIRECTORY by deleting all contained .da files.
#
# Die on error.
#

sub userspace_reset()
{
	my $current_dir;
	my @file_list;

	foreach $current_dir (@directory)
	{
		info("Deleting all .da files in $current_dir".
		     ($no_recursion?"\n":" and subdirectories\n"));
		@file_list = `find "$current_dir" $maxdepth $follow -name \\*\\.da -type f -o -name \\*\\.gcda -type f 2>/dev/null`;
		chomp(@file_list);
		foreach (@file_list)
		{
			unlink($_) or die("ERROR: cannot remove file $_!\n");
		}
	}
}


#
# userspace_capture()
#
# Capture coverage data found in DIRECTORY and write it to a package (if
# TO_PACKAGE specified) or to OUTPUT_FILENAME or STDOUT.
#
# Die on error.
#

sub userspace_capture()
{
	my $dir;
	my $build;

	if (!defined($to_package)) {
		lcov_geninfo(@directory);
		return;
	}
	if (scalar(@directory) != 1) {
		die("ERROR: -d may be specified only once with --to-package\n");
	}
	$dir = $directory[0];
	if (defined($base_directory)) {
		$build = $base_directory;
	} else {
		$build = $dir;
	}
	create_package($to_package, $dir, $build);
}


#
# kernel_reset()
#
# Reset kernel coverage.
#
# Die on error.
#

sub kernel_reset()
{
	local *HANDLE;
	my $reset_file;

	info("Resetting kernel execution counters\n");
	if (-e "$gcov_dir/vmlinux") {
		$reset_file = "$gcov_dir/vmlinux";
	} elsif (-e "$gcov_dir/reset") {
		$reset_file = "$gcov_dir/reset";
	} else {
		die("ERROR: no reset control found in $gcov_dir\n");
	}
	open(HANDLE, ">", $reset_file) or
		die("ERROR: cannot write to $reset_file!\n");
	print(HANDLE "0");
	close(HANDLE);
}


#
# lcov_copy_single(from, to)
#
# Copy single regular file FROM to TO without checking its size. This is
# required to work with special files generated by the kernel
# seq_file-interface.
#
#
sub lcov_copy_single($$)
{
	my ($from, $to) = @_;
	my $content;
	local $/;
	local *HANDLE;

	open(HANDLE, "<", $from) or die("ERROR: cannot read $from: $!\n");
	$content = <HANDLE>;
	close(HANDLE);
	open(HANDLE, ">", $to) or die("ERROR: cannot write $from: $!\n");
	if (defined($content)) {
		print(HANDLE $content);
	}
	close(HANDLE);
}

#
# lcov_find(dir, function, data[, extension, ...)])
#
# Search DIR for files and directories whose name matches PATTERN and run
# FUNCTION for each match. If not pattern is specified, match all names.
#
# FUNCTION has the following prototype:
#   function(dir, relative_name, data)
#
# Where:
#   dir: the base directory for this search
#   relative_name: the name relative to the base directory of this entry
#   data: the DATA variable passed to lcov_find
#
sub lcov_find($$$;@)
{
	my ($dir, $fn, $data, @pattern) = @_;
	my $result;
	my $_fn = sub {
		my $filename = $File::Find::name;

		if (defined($result)) {
			return;
		}
		$filename = abs2rel($filename, $dir);
		foreach (@pattern) {
			if ($filename =~ /$_/) {
				goto ok;
			}
		}
		return;
	ok:
		$result = &$fn($dir, $filename, $data);
	};
	if (scalar(@pattern) == 0) {
		@pattern = ".*";
	}
	find( { wanted => $_fn, no_chdir => 1 }, $dir);

	return $result;
}

#
# lcov_copy_fn(from, rel, to)
#
# Copy directories, files and links from/rel to to/rel.
#

sub lcov_copy_fn($$$)
{
	my ($from, $rel, $to) = @_;
	my $absfrom = canonpath(catfile($from, $rel));
	my $absto = canonpath(catfile($to, $rel));

	if (-d) {
		if (! -d $absto) {
			mkpath($absto) or
				die("ERROR: cannot create directory $absto\n");
			chmod(0700, $absto);
		}
	} elsif (-l) {
		# Copy symbolic link
		my $link = readlink($absfrom);

		if (!defined($link)) {
			die("ERROR: cannot read link $absfrom: $!\n");
		}
		symlink($link, $absto) or
			die("ERROR: cannot create link $absto: $!\n");
	} else {
		lcov_copy_single($absfrom, $absto);
		chmod(0600, $absto);
	}
	return undef;
}

#
# lcov_copy(from, to, subdirs)
#
# Copy all specified SUBDIRS and files from directory FROM to directory TO. For
# regular files, copy file contents without checking its size. This is required
# to work with seq_file-generated files.
#

sub lcov_copy($$;@)
{
	my ($from, $to, @subdirs) = @_;
	my @pattern;

	foreach (@subdirs) {
		push(@pattern, "^$_");
	}
	lcov_find($from, \&lcov_copy_fn, $to, @pattern);
}

#
# lcov_geninfo(directory)
#
# Call geninfo for the specified directory and with the parameters specified
# at the command line.
#

sub lcov_geninfo(@)
{
	my (@dir) = @_;
	my @param;

	# Capture data
	info("Capturing coverage data from ".join(" ", @dir)."\n");
	@param = ("$tool_dir/geninfo", @dir);
	if ($output_filename)
	{
		@param = (@param, "--output-filename", $output_filename);
	}
	if ($test_name)
	{
		@param = (@param, "--test-name", $test_name);
	}
	if ($follow)
	{
		@param = (@param, "--follow");
	}
	if ($lcovutil::quiet)
	{
		@param = (@param, "--quiet");
	}
	if (defined($checksum))
	{
		if ($checksum)
		{
			@param = (@param, "--checksum");
		}
		else
		{
			@param = (@param, "--no-checksum");
		}
	}
	if ($base_directory)
	{
		@param = (@param, "--base-directory", $base_directory);
	}
	if ($no_compat_libtool)
	{
		@param = (@param, "--no-compat-libtool");
	}
	elsif ($compat_libtool)
	{
		@param = (@param, "--compat-libtool");
	}
	if ($gcov_tool)
	{
		@param = (@param, "--gcov-tool", $gcov_tool);
	}
	foreach (split(',', join(',', @opt_ignore_errors))) {
	  # pass only the 'ignore' options that geninfo understands
	  @param = (@param, "--ignore-errors", $_)
	    if exists($lcovutil::geninfoErrs{$_});
	}
	foreach (@opt_filter) {
		@param = (@param, "--filter", $_);
	}
	if ($no_recursion) {
		@param = (@param, "--no-recursion");
	}
	if ($initial)
	{
		@param = (@param, "--initial");
	}
	if ($no_markers)
	{
		@param = (@param, "--no-markers");
	}
	if ($opt_derive_func_data)
	{
		@param = (@param, "--derive-func-data");
	}
	if ($lcovutil::debug)
	{
		@param = (@param, "--debug");
	}
	if (defined($opt_external) && $opt_external)
	{
		@param = (@param, "--external");
	}
	if (defined($lcovutil::opt_no_external) && $lcovutil::opt_no_external)
	{
		@param = (@param, "--no-external");
	}
	if (defined($opt_compat)) {
		@param = (@param, "--compat", $opt_compat);
	}
	if (%opt_rc) {
		foreach my $key (keys(%opt_rc)) {
			@param = (@param, "--rc", "$key=".$opt_rc{$key});
		}
	}
	if (defined($opt_config_file)) {
		@param = (@param, "--config-file", $opt_config_file);
	}
	foreach (@include_patterns) {
		@param = (@param, "--include", $_);
	}
	foreach (@exclude_patterns) {
		@param = (@param, "--exclude", $_);
	}
	info("geninfo cmd: '" . join(' ', @param) . "'\n");
	system(@param) and exit($? >> 8);
}

#
# read_file(filename)
#
# Return the contents of the file defined by filename.
#

sub read_file($)
{
	my ($filename) = @_;
	my $content;
	local $\;
	local *HANDLE;

	open(HANDLE, "<", $filename) || return undef;
	$content = <HANDLE>;
	close(HANDLE);

	return $content;
}

#
# get_package(package_file)
#
# Unpack unprocessed coverage data files from package_file to a temporary
# directory and return directory name, build directory and gcov kernel version
# as found in package.
#

sub get_package($)
{
	my ($file) = @_;
	my $dir = create_temp_dir();
	my $gkv;
	my $build;
	my $cwd = getcwd();
	my $count;
	local *HANDLE;

	info("Reading package $file:\n");
	$file = abs_path($file);
	chdir($dir);
	open(HANDLE, "-|", "tar xvfz '$file' 2>/dev/null")
		or die("ERROR: could not process package $file\n");
	$count = 0;
	while (<HANDLE>) {
		if (/\.da$/ || /\.gcda$/) {
			$count++;
		}
	}
	close(HANDLE);
	if ($count == 0) {
		die("ERROR: no data file found in package $file\n");
	}
	info("  data directory .......: $dir\n");
	$build = read_file("$dir/$pkg_build_file");
	if (defined($build)) {
		info("  build directory ......: $build\n");
	}
	$gkv = read_file("$dir/$pkg_gkv_file");
	if (defined($gkv)) {
		$gkv = int($gkv);
		if ($gkv != $GKV_PROC && $gkv != $GKV_SYS) {
			die("ERROR: unsupported gcov kernel version found ".
			    "($gkv)\n");
		}
		info("  content type .........: kernel data\n");
		info("  gcov kernel version ..: %s\n", $GKV_NAME[$gkv]);
	} else {
		info("  content type .........: application data\n");
	}
	info("  data files ...........: $count\n");
	chdir($cwd);

	return ($dir, $build, $gkv);
}

#
# write_file(filename, $content)
#
# Create a file named filename and write the specified content to it.
#

sub write_file($$)
{
	my ($filename, $content) = @_;
	local *HANDLE;

	open(HANDLE, ">", $filename) || return 0;
	print(HANDLE $content);
	close(HANDLE) || return 0;

	return 1;
}

# count_package_data(filename)
#
# Count the number of coverage data files in the specified package file.
#

sub count_package_data($)
{
	my ($filename) = @_;
	local *HANDLE;
	my $count = 0;

	open(HANDLE, "-|", "tar tfz '$filename'") or return undef;
	while (<HANDLE>) {
		if (/\.da$/ || /\.gcda$/) {
			$count++;
		}
	}
	close(HANDLE);
	return $count;
}

#
# create_package(package_file, source_directory, build_directory[,
# 		 kernel_gcov_version])
#
# Store unprocessed coverage data files from source_directory to package_file.
#

sub create_package($$$;$)
{
	my ($file, $dir, $build, $gkv) = @_;
	my $cwd = getcwd();

	# Check for availability of tar tool first
	system("tar --help > /dev/null")
		and die("ERROR: tar command not available\n");

	# Print information about the package
	info("Creating package $file:\n");
	info("  data directory .......: $dir\n");

	# Handle build directory
	if (defined($build)) {
		info("  build directory ......: $build\n");
		write_file("$dir/$pkg_build_file", $build)
			or die("ERROR: could not write to ".
			       "$dir/$pkg_build_file\n");
	}

	# Handle gcov kernel version data
	if (defined($gkv)) {
		info("  content type .........: kernel data\n");
		info("  gcov kernel version ..: %s\n", $GKV_NAME[$gkv]);
		write_file("$dir/$pkg_gkv_file", $gkv)
			or die("ERROR: could not write to ".
			       "$dir/$pkg_gkv_file\n");
	} else {
		info("  content type .........: application data\n");
	}

	# Create package
	$file = abs_path($file);
	chdir($dir);
	system("tar cfz $file .")
		and die("ERROR: could not create package $file\n");
	chdir($cwd);

	# Remove temporary files
	unlink("$dir/$pkg_build_file");
	unlink("$dir/$pkg_gkv_file");

	# Show number of data files
	if (!$lcovutil::quiet) {
		my $count = count_package_data($file);

		if (defined($count)) {
			info("  data files ...........: $count\n");
		}
	}
}

sub find_link_fn($$$)
{
	my ($from, $rel, $filename) = @_;
	my $absfile = catfile($from, $rel, $filename);

	if (-l $absfile) {
		return $absfile;
	}
	return undef;
}

#
# get_base(dir)
#
# Return (BASE, OBJ), where
#  - BASE: is the path to the kernel base directory relative to dir
#  - OBJ: is the absolute path to the kernel build directory
#

sub get_base($)
{
	my ($dir) = @_;
	my $marker = "kernel/gcov/base.gcno";
	my $markerfile;
	my $sys;
	my $obj;
	my $link;

	$markerfile = lcov_find($dir, \&find_link_fn, $marker);
	if (!defined($markerfile)) {
		return (undef, undef);
	}

	# sys base is parent of parent of markerfile.
	$sys = abs2rel(dirname(dirname(dirname($markerfile))), $dir);

	# obj base is parent of parent of markerfile link target.
	$link = readlink($markerfile);
	if (!defined($link)) {
		die("ERROR: could not read $markerfile\n");
	}
	$obj = dirname(dirname(dirname($link)));

	return ($sys, $obj);
}

#
# apply_base_dir(data_dir, base_dir, build_dir, @directories)
#
# Make entries in @directories relative to data_dir.
#

sub apply_base_dir($$$@)
{
	my ($data, $base, $build, @dirs) = @_;
	my $dir;
	my @result;

	foreach $dir (@dirs) {
		# Is directory path relative to data directory?
		if (-d catdir($data, $dir)) {
			push(@result, $dir);
			next;
		}
		# Relative to the auto-detected base-directory?
		if (defined($base)) {
			if (-d catdir($data, $base, $dir)) {
				push(@result, catdir($base, $dir));
				next;
			}
		}
		# Relative to the specified base-directory?
		if (defined($base_directory)) {
			if (file_name_is_absolute($base_directory)) {
				$base = abs2rel($base_directory, rootdir());
			} else {
				$base = $base_directory;
			}
			if (-d catdir($data, $base, $dir)) {
				push(@result, catdir($base, $dir));
				next;
			}
		}
		# Relative to the build directory?
		if (defined($build)) {
			if (file_name_is_absolute($build)) {
				$base = abs2rel($build, rootdir());
			} else {
				$base = $build;
			}
			if (-d catdir($data, $base, $dir)) {
				push(@result, catdir($base, $dir));
				next;
			}
		}
		die("ERROR: subdirectory $dir not found\n".
		    "Please use -b to specify the correct directory\n");
	}
	return @result;
}

#
# copy_gcov_dir(dir, [@subdirectories])
#
# Create a temporary directory and copy all or, if specified, only some
# subdirectories from dir to that directory. Return the name of the temporary
# directory.
#

sub copy_gcov_dir($;@)
{
	my ($data, @dirs) = @_;
	my $tempdir = create_temp_dir();

	info("Copying data to temporary directory $tempdir\n");
	lcov_copy($data, $tempdir, @dirs);

	return $tempdir;
}

#
# kernel_capture_initial
#
# Capture initial kernel coverage data, i.e. create a coverage data file from
# static graph files which contains zero coverage data for all instrumented
# lines.
#

sub kernel_capture_initial()
{
	my $build;
	my $source;
	my @params;

	if (defined($base_directory)) {
		$build = $base_directory;
		$source = "specified";
	} else {
		(undef, $build) = get_base($gcov_dir);
		if (!defined($build)) {
			die("ERROR: could not auto-detect build directory.\n".
			    "Please use -b to specify the build directory\n");
		}
		$source = "auto-detected";
	}
	info("Using $build as kernel build directory ($source)\n");
	# Build directory needs to be passed to geninfo
	$base_directory = $build;
	if (@kernel_directory) {
		foreach my $dir (@kernel_directory) {
			push(@params, "$build/$dir");
		}
	} else {
		push(@params, $build);
	}
	lcov_geninfo(@params);
}

#
# kernel_capture_from_dir(directory, gcov_kernel_version, build)
#
# Perform the actual kernel coverage capturing from the specified directory
# assuming that the data was copied from the specified gcov kernel version.
#

sub kernel_capture_from_dir($$$)
{
	my ($dir, $gkv, $build) = @_;

	# Create package or coverage file
	if (defined($to_package)) {
		create_package($to_package, $dir, $build, $gkv);
	} else {
		# Build directory needs to be passed to geninfo
		$base_directory = $build;
		lcov_geninfo($dir);
	}
}

#
# adjust_kernel_dir(dir, build)
#
# Adjust directories specified with -k so that they point to the directory
# relative to DIR. Return the build directory if specified or the auto-
# detected build-directory.
#

sub adjust_kernel_dir($$)
{
	my ($dir, $build) = @_;
	my ($sys_base, $build_auto) = get_base($dir);

	if (!defined($build)) {
		$build = $build_auto;
	}
	if (!defined($build)) {
		die("ERROR: could not auto-detect build directory.\n".
		    "Please use -b to specify the build directory\n");
	}
	# Make @kernel_directory relative to sysfs base
	if (@kernel_directory) {
		@kernel_directory = apply_base_dir($dir, $sys_base, $build,
						   @kernel_directory);
	}
	return $build;
}

sub kernel_capture()
{
	my $data_dir;
	my $build = $base_directory;

	if ($gcov_gkv == $GKV_SYS) {
		$build = adjust_kernel_dir($gcov_dir, $build);
	}
	$data_dir = copy_gcov_dir($gcov_dir, @kernel_directory);
	kernel_capture_from_dir($data_dir, $gcov_gkv, $build);
}

#
# link_data_cb(datadir, rel, graphdir)
#
# Create symbolic link in GRAPDIR/REL pointing to DATADIR/REL.
#

sub link_data_cb($$$)
{
	my ($datadir, $rel, $graphdir) = @_;
	my $absfrom = catfile($datadir, $rel);
	my $absto = catfile($graphdir, $rel);
	my $base;
	my $dir;

	if (-e $absto) {
		die("ERROR: could not create symlink at $absto: ".
		    "File already exists!\n");
	}
	if (-l $absto) {
		# Broken link - possibly from an interrupted earlier run
		unlink($absto);
	}

	# Check for graph file
	$base = $absto;
	$base =~ s/\.(gcda|da)$//;
	if (! -e $base.".gcno" && ! -e $base.".bbg" && ! -e $base.".bb") {
		die("ERROR: No graph file found for $absfrom in ".
		    dirname($base)."!\n");
	}

	symlink($absfrom, $absto) or
		die("ERROR: could not create symlink at $absto: $!\n");
}

#
# unlink_data_cb(datadir, rel, graphdir)
#
# Remove symbolic link from GRAPHDIR/REL to DATADIR/REL.
#

sub unlink_data_cb($$$)
{
	my ($datadir, $rel, $graphdir) = @_;
	my $absfrom = catfile($datadir, $rel);
	my $absto = catfile($graphdir, $rel);
	my $target;

	return if (!-l $absto);
	$target = readlink($absto);
	return if (!defined($target) || $target ne $absfrom);

	unlink($absto) or
		warn("WARNING: could not remove symlink $absto: $!\n");
}

#
# link_data(datadir, graphdir, create)
#
# If CREATE is non-zero, create symbolic links in GRAPHDIR for data files
# found in DATADIR. Otherwise remove link in GRAPHDIR.
#

sub link_data($$$)
{
	my ($datadir, $graphdir, $create) = @_;

	$datadir = abs_path($datadir);
	$graphdir = abs_path($graphdir);
	if ($create) {
		lcov_find($datadir, \&link_data_cb, $graphdir, '\.gcda$',
			  '\.da$');
	} else {
		lcov_find($datadir, \&unlink_data_cb, $graphdir, '\.gcda$',
			  '\.da$');
	}
}

#
# find_graph_cb(datadir, rel, count_ref)
#
# Count number of files found.
#

sub find_graph_cb($$$)
{
	my ($dir, $rel, $count_ref) = @_;

	($$count_ref)++;
}

#
# find_graph(dir)
#
# Search DIR for a graph file. Return non-zero if one was found, zero otherwise.
#

sub find_graph($)
{
	my ($dir) = @_;
	my $count = 0;

	lcov_find($dir, \&find_graph_cb, \$count, '\.gcno$', '\.bb$', '\.bbg$');

	return $count > 0 ? 1 : 0;
}

#
# package_capture()
#
# Capture coverage data from a package of unprocessed coverage data files
# as generated by lcov --to-package.
#

sub package_capture()
{
	my $dir;
	my $build;
	my $gkv;

	($dir, $build, $gkv) = get_package($from_package);

	# Check for build directory
	if (defined($base_directory)) {
		if (defined($build)) {
			info("Using build directory specified by -b.\n");
		}
		$build = $base_directory;
	}

	# Do the actual capture
	if (defined($gkv)) {
		if ($gkv == $GKV_SYS) {
			$build = adjust_kernel_dir($dir, $build);
		}
		if (@kernel_directory) {
			$dir = copy_gcov_dir($dir, @kernel_directory);
		}
		kernel_capture_from_dir($dir, $gkv, $build);
	} else {
		# Build directory needs to be passed to geninfo
		$base_directory = $build;
		if (find_graph($dir)) {
			# Package contains graph files - collect from there
			lcov_geninfo($dir);
		} else {
			# No graph files found, link data files next to
			# graph files
			link_data($dir, $base_directory, 1);
			lcov_geninfo($base_directory);
			link_data($dir, $base_directory, 0);
		}
	}
}


#
# info(printf_parameter)
#
# Use printf to write PRINTF_PARAMETER to stdout only when the $quiet flag
# is not set.
#

sub my_info(@)
{
	if (!$quiet)
	{
		# Print info string
		if (!$data_stdout)
		{
			printf(@_)
		}
		else
		{
			# Don't interfere with the .info output to STDOUT
			printf(STDERR @_);
		}
	}
}


#
# create_temp_dir()
#
# Create a temporary directory and return its path.
#
# Die on error.
#

sub create_temp_dir()
{
	my $dir;

	if (defined($tmp_dir)) {
		$dir = tempdir(DIR => $tmp_dir, CLEANUP => 1);
	} else {
		$dir = tempdir(CLEANUP => 1);
	}
	if (!defined($dir)) {
		die("ERROR: cannot create temporary directory\n");
	}
	append_tempdir($dir);

	return $dir;
}

#
#
# add_traces()
#

sub add_traces()
{
	my $total_trace = TraceFile->new();
	my @result;
	local *INFO_HANDLE;

	info("Combining tracefiles.\n");
	my $readSourceFile = ReadCurrentSource->new();
	foreach my $tracefile (@add_tracefile)
	{
		my $current = TraceFile->load($tracefile, $readSourceFile);
		$total_trace->append_tracefile($current);
	}

	# Write combined data
	if (!$data_stdout)
	{
		info("Writing data to $output_filename\n");
		# Check for .gz extension
		if ($output_filename =~ /\.gz$/)
		{
		        # Check for availability of GZIP tool
		        system_no_output(1, "gzip" ,"-h")
			        and die("ERROR: gzip command not available!\n");

			# Open compressed file
			open(INFO_HANDLE, "|-", "gzip -c >$output_filename")
			        or die("ERROR: cannot start gzip to compress ".
				       "to file $output_filename!\n");
		} else {
		        open(INFO_HANDLE, ">", $output_filename)
			        or die("ERROR: cannot write to $output_filename!\n");
		}
		@result = $total_trace->write_info(*INFO_HANDLE, $checksum);
		close(*INFO_HANDLE);
	}
	else
	{
		@result = $total_trace->write_info(*STDOUT, $checksum);
	}

	return @result;
}



#
# extract()
#

sub extract()
{
	my $readSourceFile = ReadCurrentSource->new();
	my $data = TraceFile->load($extract, $readSourceFile);
	my $extracted = 0;
	my @result;
	local *INFO_HANDLE;

	# Need perlreg expressions instead of shell pattern
	my @pattern_list = map({ lcovutil::transform_pattern($_); } @ARGV);

	# Filter out files which do not match any pattern
	foreach my $filename (sort($data->files())) {
		my $keep = 0;

		foreach my $pattern (@pattern_list)
		{
			$keep ||= ($filename =~ (/^$pattern$/));
		}


		if (!$keep)
		{
			$data->remove($filename);
		}
		else
		{
			info("Extracting $filename\n"),
			$extracted++;
		}
	}

	# Write extracted data
	if (!$data_stdout)
	{
		info("Extracted $extracted files\n");
		info("Writing data to $output_filename\n");
		if ($output_filename =~ /\.gz$/)
		{
			# Check for availability of GZIP tool
			system_no_output(1, "gzip" ,"-h")
				and die("ERROR: gzip command not available!\n");

			# Open compressed file
			open(INFO_HANDLE, "|-", "gzip -c >$output_filename")
				or die("ERROR: cannot start gzip to compress ".
				       "to file $output_filename!\n");
		} else {
			open(INFO_HANDLE, ">", $output_filename)
				or die("ERROR: cannot write to $output_filename!\n");
		}
		@result = $data->write_info(*INFO_HANDLE, $checksum);
		close(*INFO_HANDLE);
	}
	else
	{
		@result = $data->write_info(*STDOUT, $checksum);
	}

	return @result;
}


#
# remove()
#

sub remove()
{
	my $readSourceFile = ReadCurrentSource->new();
	my $data = TraceFile->load($remove, $readSourceFile);
	my @pattern_list;
	my $removed = 0;
	my @result;
	local *INFO_HANDLE;

	# Need perlreg expressions instead of shell pattern
	@pattern_list = map({ lcovutil::transform_pattern($_); } @ARGV);

	# Filter out files that match the pattern
	foreach my $filename (sort($data->files())) {
		my $match_found = 0;

		foreach my $pattern (@pattern_list)
		{
			$match_found ||= ($filename =~ (/^$pattern$/));
		}


		if ($match_found)
		{
			$data->remove($filename);
			info("Removing $filename\n"),
			$removed++;
		}
	}

	# Write data
	if (!$data_stdout)
	{
		info("Deleted $removed files\n");
		info("Writing data to $output_filename\n");
		if ($output_filename =~ /\.gz$/)
		{
			# Check for availability of GZIP tool
			system_no_output(1, "gzip" ,"-h")
				and die("ERROR: gzip command not available!\n");

			# Open compressed file
			open(INFO_HANDLE, "|-", "gzip -c >$output_filename")
				or die("ERROR: cannot start gzip to compress ".
				       "to file $output_filename!\n");
		} else {
			open(INFO_HANDLE, ">", $output_filename)
				or die("ERROR: cannot write to $output_filename!\n");
		}
		@result = $data->write_info(*INFO_HANDLE, $data, $checksum);
		close(*INFO_HANDLE);
	}
	else
	{
		@result = $data->write_info(*STDOUT, $checksum);
	}

	return @result;
}


# get_prefix(max_width, max_percentage_too_long, path_list)
#
# Return a path prefix that satisfies the following requirements:
# - is shared by more paths in path_list than any other prefix
# - the percentage of paths which would exceed the given max_width length
#   after applying the prefix does not exceed max_percentage_too_long
#
# If multiple prefixes satisfy all requirements, the longest prefix is
# returned. Return an empty string if no prefix could be found.

sub get_prefix($$@)
{
	my ($max_width, $max_long, @path_list) = @_;
	my $path;
	my $ENTRY_NUM = 0;
	my $ENTRY_LONG = 1;
	my %prefix;

	# Build prefix hash
	foreach $path (@path_list) {
		my ($v, $d, $f) = splitpath($path);
		my @dirs = splitdir($d);
		my $p_len = length($path);

		# Remove trailing '/'
		pop(@dirs)
		  if (0 != scalar(@dirs) && $dirs[scalar(@dirs) - 1] eq '');
		for (my $i = 0; $i < scalar(@dirs); $i++) {
			my $subpath = catpath($v, catdir(@dirs[0..$i]), '');
			my $entry = $prefix{$subpath};

			$entry = [ 0, 0 ] if (!defined($entry));
			$entry->[$ENTRY_NUM]++;
			if (($p_len - length($subpath) - 1) > $max_width) {
				$entry->[$ENTRY_LONG]++;
			}
			$prefix{$subpath} = $entry;
		}
	}
	# Find suitable prefix (sort descending by two keys: 1. number of
	# entries covered by a prefix, 2. length of prefix)
	foreach $path (sort {($prefix{$a}->[$ENTRY_NUM] ==
			      $prefix{$b}->[$ENTRY_NUM]) ?
				length($b) <=> length($a) :
				$prefix{$b}->[$ENTRY_NUM] <=>
				$prefix{$a}->[$ENTRY_NUM]}
				keys(%prefix)) {
		my ($num, $long) = @{$prefix{$path}};

		# Check for additional requirement: number of filenames
		# that would be too long may not exceed a certain percentage
		if ($long <= $num * $max_long / 100) {
			return $path;
		}
	}

	return "";
}


#
# shorten_filename(filename, width)
#
# Truncate filename if it is longer than width characters.
#

sub shorten_filename($$)
{
	my ($filename, $width) = @_;
	my $l = length($filename);
	my $s;
	my $e;

	return $filename if ($l <= $width);
	$e = int(($width - 3) / 2);
	$s = $width - 3 - $e;

	return substr($filename, 0, $s).'...'.substr($filename, $l - $e);
}


sub shorten_number($$)
{
	my ($number, $width) = @_;
	my $result = sprintf("%*d", $width, $number);

	return $result if (length($result) <= $width);
	$number = $number / 1000;
	return $result if (length($result) <= $width);
	$result = sprintf("%*dk", $width - 1, $number);
	return $result if (length($result) <= $width);
	$number = $number / 1000;
	$result = sprintf("%*dM", $width - 1, $number);
	return $result if (length($result) <= $width);
	return '#';
}

sub shorten_rate($$$)
{
	my ($hit, $found, $width) = @_;
	my $result = rate($hit, $found, "%", 1, $width);

	return $result if (length($result) <= $width);
	$result = rate($hit, $found, "%", 0, $width);
	return $result if (length($result) <= $width);
	return "#";
}

#
# list()
#

sub list()
{
	my $readSourceFile = ReadCurrentSource->new();
	my $data = TraceFile->load($list, $readSourceFile);
	my $found;
	my $hit;
	my $entry;
	my $fn_found;
	my $fn_hit;
	my $br_found;
	my $br_hit;
	my $total_found = 0;
	my $total_hit = 0;
	my $fn_total_found = 0;
	my $fn_total_hit = 0;
	my $br_total_found = 0;
	my $br_total_hit = 0;
	my $strlen = length("Filename");
	my @footer;
	my $rate;
	my $fnrate;
	my $brrate;
	my $lastpath;
	my $F_LN_NUM = 0;
	my $F_LN_RATE = 1;
	my $F_FN_NUM = 2;
	my $F_FN_RATE = 3;
	my $F_BR_NUM = 4;
	my $F_BR_RATE = 5;
	my @fwidth_narrow = (5, 5, 3, 5, 4, 5);
	my @fwidth_wide = (6, 5, 5, 5, 6, 5);
	my @fwidth = @fwidth_wide;
	my $max_width = $opt_list_width;
	my $max_long = $opt_list_truncate_max;

	# Calculate total width of narrow fields
	my $fwidth_narrow_length = 0;
	foreach my $w (@fwidth_narrow) {
		$fwidth_narrow_length += $w + 1;
	}
	# Calculate total width of wide fields
	my $fwidth_wide_length = 0;
	foreach my $w (@fwidth_wide) {
		$fwidth_wide_length += $w + 1;
	}
	# Get common file path prefix
	my $prefix = get_prefix($max_width - $fwidth_narrow_length,
				$max_long, keys(%{$data}));
	my $root_prefix = ($prefix eq rootdir());
	my $got_prefix = (length($prefix) > 0);
	$prefix =~ s/\/$//;
	# Get longest filename length
	foreach my $filename ($data->files()) {
		if (!$opt_list_full_path) {
			if (!$got_prefix || !$root_prefix &&
			    !($filename =~ s/^\Q$prefix\/\E//)) {
				my ($v, $d, $f) = splitpath($filename);

				$filename = $f;
			}
		}
		# Determine maximum length of entries
		if (length($filename) > $strlen) {
			$strlen = length($filename)
		}
	}
	if (!$opt_list_full_path) {

		my $w = $fwidth_wide_length;
		# Check if all columns fit into max_width characters
		if ($strlen + $fwidth_wide_length > $max_width) {
			# Use narrow fields
			@fwidth = @fwidth_narrow;
			$w = $fwidth_narrow_length;
			if (($strlen + $fwidth_narrow_length) > $max_width) {
				# Truncate filenames at max width
				$strlen = $max_width - $fwidth_narrow_length;
			}
		}
		# Add some blanks between filename and fields if possible
		my $blanks = int($strlen * 0.5);
		$blanks = 4 if ($blanks < 4);
		$blanks = 8 if ($blanks > 8);
		if (($strlen + $w + $blanks) < $max_width) {
			$strlen += $blanks;
		} else {
			$strlen = $max_width - $w;
		}
	}
	# Filename
	my $w = $strlen;
	my $format      = "%-${w}s|";
	my $heading1    = sprintf("%*s|", $w, "");
	my $heading2    = sprintf("%-*s|", $w, "Filename");
	my $barlen      = $w + 1;
	# Line coverage rate
	$w = $fwidth[$F_LN_RATE];
	$format	 .= "%${w}s ";
	$heading1       .= sprintf("%-*s |", $w + $fwidth[$F_LN_NUM],
				   "Lines");
	$heading2       .= sprintf("%-*s ", $w, "Rate");
	$barlen	 += $w + 1;
	# Number of lines
	$w = $fwidth[$F_LN_NUM];
	$format	 .= "%${w}s|";
	$heading2       .= sprintf("%*s|", $w, "Num");
	$barlen	 += $w + 1;
	# Function coverage rate
	$w = $fwidth[$F_FN_RATE];
	$format	 .= "%${w}s ";
	$heading1       .= sprintf("%-*s|", $w + $fwidth[$F_FN_NUM] + 1,
				   "Functions");
	$heading2       .= sprintf("%-*s ", $w, "Rate");
	$barlen	 += $w + 1;
	# Number of functions
	$w = $fwidth[$F_FN_NUM];
	$format	 .= "%${w}s|";
	$heading2       .= sprintf("%*s|", $w, "Num");
	$barlen	 += $w + 1;
	# Branch coverage rate
	$w = $fwidth[$F_BR_RATE];
	$format	 .= "%${w}s ";
	$heading1       .= sprintf("%-*s", $w + $fwidth[$F_BR_NUM] + 1,
				   "Branches");
	$heading2       .= sprintf("%-*s ", $w, "Rate");
	$barlen	 += $w + 1;
	# Number of branches
	$w = $fwidth[$F_BR_NUM];
	$format	 .= "%${w}s";
	$heading2       .= sprintf("%*s", $w, "Num");
	$barlen	 += $w;
	# Line end
	$format	 .= "\n";
	$heading1       .= "\n";
	$heading2       .= "\n";

	# Print heading
	print($heading1);
	print($heading2);
	print(("="x$barlen)."\n");

	# Print per file information
	foreach my $filename (sort($data->files())) {
		my @file_data;
		my $print_filename = $filename;

		my $entry = $data->data($filename);
		if (!$opt_list_full_path) {
			my $p;

			$print_filename = $filename;
			if (!$got_prefix || !$root_prefix &&
			    !($print_filename =~ s/^\Q$prefix\/\E//)) {
				my ($v, $d, $f) = splitpath($filename);

				$p = catpath($v, $d, "");
				$p =~ s/\/$//;
				$print_filename = $f;
			} else {
				$p = $prefix;
			}

			if (!defined($lastpath) || $lastpath ne $p) {
				print("\n") if (defined($lastpath));
				$lastpath = $p;
				print("[$lastpath/]\n") if (!$root_prefix);
			}
			$print_filename = shorten_filename($print_filename,
							   $strlen);
		}

		(undef, undef, undef, undef, undef, undef, undef, undef,
		 $found, $hit, $fn_found, $fn_hit, $br_found, $br_hit) =
			$entry->get_info();

		# Assume zero count if there is no function data for this file
		if (!defined($fn_found) || !defined($fn_hit)) {
			$fn_found = 0;
			$fn_hit = 0;
		}
		# Assume zero count if there is no branch data for this file
		if (!defined($br_found) || !defined($br_hit)) {
			$br_found = 0;
			$br_hit = 0;
		}

		# Add line coverage totals
		$total_found += $found;
		$total_hit += $hit;
		# Add function coverage totals
		$fn_total_found += $fn_found;
		$fn_total_hit += $fn_hit;
		# Add branch coverage totals
		$br_total_found += $br_found;
		$br_total_hit += $br_hit;

		# Determine line coverage rate for this file
		$rate = shorten_rate($hit, $found, $fwidth[$F_LN_RATE]);
		# Determine function coverage rate for this file
		$fnrate = shorten_rate($fn_hit, $fn_found, $fwidth[$F_FN_RATE]);
		# Determine branch coverage rate for this file
		$brrate = shorten_rate($br_hit, $br_found, $fwidth[$F_BR_RATE]);

		# Assemble line parameters
		push(@file_data, $print_filename);
		push(@file_data, $rate);
		push(@file_data, shorten_number($found, $fwidth[$F_LN_NUM]));
		push(@file_data, $fnrate);
		push(@file_data, shorten_number($fn_found, $fwidth[$F_FN_NUM]));
		push(@file_data, $brrate);
		push(@file_data, shorten_number($br_found, $fwidth[$F_BR_NUM]));

		# Print assembled line
		printf($format, @file_data);
	}

	# Determine total line coverage rate
	$rate = shorten_rate($total_hit, $total_found, $fwidth[$F_LN_RATE]);
	# Determine total function coverage rate
	$fnrate = shorten_rate($fn_total_hit, $fn_total_found,
			       $fwidth[$F_FN_RATE]);
	# Determine total branch coverage rate
	$brrate = shorten_rate($br_total_hit, $br_total_found,
			       $fwidth[$F_BR_RATE]);

	# Print separator
	print(("="x$barlen)."\n");

	# Assemble line parameters
	push(@footer, sprintf("%*s", $strlen, "Total:"));
	push(@footer, $rate);
	push(@footer, shorten_number($total_found, $fwidth[$F_LN_NUM]));
	push(@footer, $fnrate);
	push(@footer, shorten_number($fn_total_found, $fwidth[$F_FN_NUM]));
	push(@footer, $brrate);
	push(@footer, shorten_number($br_total_found, $fwidth[$F_BR_NUM]));

	# Print assembled line
	printf($format, @footer);
}


#
# get_common_filename(filename1, filename2)
#
# Check for filename components which are common to FILENAME1 and FILENAME2.
# Upon success, return
#
#   (common, path1, path2)
#
#  or 'undef' in case there are no such parts.
#

sub get_common_filename($$)
{
	my @list1 = split("/", $_[0]);
	my @list2 = split("/", $_[1]);
	my @result;

	# Work in reverse order, i.e. beginning with the filename itself
	while (@list1 && @list2 && ($list1[$#list1] eq $list2[$#list2]))
	{
		unshift(@result, pop(@list1));
		pop(@list2);
	}

	# Did we find any similarities?
	if (scalar(@result) > 0)
	{
		return (join("/", @result), join("/", @list1),
			join("/", @list2));
	}
	else
	{
		return undef;
	}
}


#
# read_diff(filename)
#
# Read diff output from FILENAME to memory. The diff file has to follow the
# format generated by 'diff -u'. Returns a list of hash references:
#
#   (mapping, path mapping)
#
#   mapping:   filename -> reference to line hash
#   line hash: line number in new file -> corresponding line number in old file
#
#   path mapping:  filename -> old filename
#
# Die in case of error.
#

sub read_diff($)
{
	my $diff_file = $_[0];  # Name of diff file
	my %diff;	       # Resulting mapping filename -> line hash
	my %paths;	      # Resulting mapping old path  -> new path
	my $mapping;	    # Reference to current line hash
	my $line;	       # Contents of current line
	my $num_old;	    # Current line number in old file
	my $num_new;	    # Current line number in new file
	my $file_old;	   # Name of old file in diff section
	my $file_new;	   # Name of new file in diff section
	my $filename;	   # Name of common filename of diff section
	my $in_block = 0;       # Non-zero while we are inside a diff block
	local *HANDLE;	  # File handle for reading the diff file

	info("Reading diff $diff_file\n");

	# Check if file exists and is readable
	stat($diff_file);
	if (!(-r _))
	{
		die("ERROR: cannot read file $diff_file!\n");
	}

	# Check if this is really a plain file
	if (!(-f _))
	{
		die("ERROR: not a plain file: $diff_file!\n");
	}

	# Check for .gz extension
	if ($diff_file =~ /\.gz$/)
	{
		# Check for availability of GZIP tool
		system_no_output(1, "gunzip", "-h")
			and die("ERROR: gunzip command not available!\n");

		# Check integrity of compressed file
		system_no_output(1, "gunzip", "-t", $diff_file)
			and die("ERROR: integrity check failed for ".
				"compressed file $diff_file!\n");

		# Open compressed file
		open(HANDLE, "-|", "gunzip -c '$diff_file'")
			or die("ERROR: cannot start gunzip to decompress ".
			       "file $_[0]!\n");
	}
	else
	{
		# Open decompressed file
		open(HANDLE, "<", $diff_file)
			or die("ERROR: cannot read file $_[0]!\n");
	}

	# Parse diff file line by line
	while (<HANDLE>)
	{
		chomp($_);
		$line = $_;

		foreach ($line)
		{
			# Filename of old file:
			# --- <filename> <date>
			/^--- (\S+)/ && do
			{
				$file_old = lcovutil::strip_directories($1, $strip);
				last;
			};
			# Filename of new file:
			# +++ <filename> <date>
			/^\+\+\+ (\S+)/ && do
			{
				# Add last file to resulting hash
				if ($filename)
				{
					my %new_hash;
					$diff{$filename} = $mapping;
					$mapping = \%new_hash;
				}
				$file_new = lcovutil::strip_directories($1, $strip);
				$filename = $file_old;
				$paths{$filename} = $file_new;
				$num_old = 1;
				$num_new = 1;
				last;
			};
			# Start of diff block:
			# @@ -old_start,old_num, +new_start,new_num @@
			/^\@\@\s+-(\d+),(\d+)\s+\+(\d+),(\d+)\s+\@\@$/ && do
			{
			$in_block = 1;
			while ($num_old < $1)
			{
				$mapping->{$num_new} = $num_old;
				$num_old++;
				$num_new++;
			}
			last;
			};
			# Unchanged line
			# <line starts with blank>
			/^ / && do
			{
				if ($in_block == 0)
				{
					last;
				}
				$mapping->{$num_new} = $num_old;
				$num_old++;
				$num_new++;
				last;
			};
			# Line as seen in old file
			# <line starts with '-'>
			/^-/ && do
			{
				if ($in_block == 0)
				{
					last;
				}
				$num_old++;
				last;
			};
			# Line as seen in new file
			# <line starts with '+'>
			/^\+/ && do
			{
				if ($in_block == 0)
				{
					last;
				}
				$num_new++;
				last;
			};
			# Empty line
			/^$/ && do
			{
				if ($in_block == 0)
				{
					last;
				}
				$mapping->{$num_new} = $num_old;
				$num_old++;
				$num_new++;
				last;
			};
		}
	}

	close(HANDLE);

	# Add final diff file section to resulting hash
	if ($filename)
	{
		$diff{$filename} = $mapping;
	}

	if (!%diff)
	{
		die("ERROR: no valid diff data found in $diff_file!\n".
		    "Make sure to use 'diff -u' when generating the diff ".
		    "file.\n");
	}
	return (\%diff, \%paths);
}


#
# apply_diff($count_data, $line_hash)
#
# Transform count data using a mapping of lines:
#
#   $count_data: reference to hash: line number -> data
#   $line_hash:  reference to hash: line number new -> line number old
#
# Return a reference to transformed count data.
#

sub apply_diff($$)
{
	my $count_data = $_[0]; # CountData: line -> hit count
	my $line_hash = $_[1];  # Reference to line hash: new line -> old line
	my $result = eval ref($count_data) . "->new()";
	my $last_new = 0;       # Last new line number found in line hash
	my $last_old = 0;       # Last old line number found in line hash

	# Iterate all new line numbers found in the diff
	foreach (sort({$a <=> $b} keys(%{$line_hash})))
	{
		$last_new = $_;
		$last_old = $line_hash->{$last_new};
		my $old_line = $line_hash->{$_};
		# Is there data associated with the corresponding old line?
		my $hit = $count_data->value($old_line);
		if (defined($hit))
		{
			# Copy data to new hash with a new line number
			$result->append($_, $hit);
		}
	}
	# Transform all other lines which come after the last diff entry
	my $delta = $last_new - $last_old;
	foreach (sort({$a <=> $b} $count_data->keylist())) {
		if ($_ <= $last_old)
		{
			# Skip lines which were covered by line hash
			next;
		}
		# Copy data to new hash with an offset
		$result->append($_ + $delta, $count_data->value($_));
	}

	return $result->_summary(); # set counts, etc
}


#
# get_hash_max(hash_ref)
#
# Return the highest integer key from hash.
#

sub get_hash_max($)
{
	my ($hash) = @_;
	my $max;

	foreach (keys(%{$hash})) {
		if (!defined($max)) {
			$max = $_;
		} elsif ($hash->{$_} > $max) {
			$max = $_;
		}
	}
	return $max;
}

sub get_hash_reverse($)
{
	my ($hash) = @_;
	my %result;

	foreach (keys(%{$hash})) {
		$result{$hash->{$_}} = $_;
	}

	return \%result;
}

#
# apply_diff_to_funcdata(funcdata, line_hash)
#

sub apply_diff_to_funcdata($$)
{
  my ($funcdata, $linedata) = @_;
  my $last_new = get_hash_max($linedata);
  my $last_old = $linedata->{$last_new};
  my $result = FunctionMap->new();
  my $line_diff = get_hash_reverse($linedata);

  foreach my $key ($funcdata->keylist()) {
    my $func = $funcdata->findKey($key);
    my $line = $func->line();

    if (defined($line_diff->{$line})) {
      $line = $line_diff->{$line};
    } elsif ($line > $last_old) {
      $line += $last_new - $last_old;
    }
    my $aliases = $func->aliases();
    foreach my $alias (keys %$aliases) {
      $result->define_function($alias, $func->file(), $line);
      $result->add_count($alias, $aliases->{$alias});
    }
  }
  return $result;
}


#
# get_line_hash($filename, $diff_data, $path_data)
#
# Find line hash in DIFF_DATA which matches FILENAME. On success, return list
# line hash. or undef in case of no match. Die if more than one line hashes in
# DIFF_DATA match.
#

sub get_line_hash($$$)
{
	my $filename = $_[0];
	my $diff_data = $_[1];
	my $path_data = $_[2];
	my $conversion;
	my $old_path;
	my $new_path;
	my $diff_name;
	my $common;
	my $old_depth;
	my $new_depth;

	# Remove trailing slash from diff path
	$diff_path =~ s/\/$//;
	foreach (keys(%{$diff_data}))
	{
		my $sep = "";

		$sep = '/' if (!/^\//);

		# Try to match diff filename with filename
		if ($filename =~ /^\Q$diff_path$sep$_\E$/)
		{
			if ($diff_name)
			{
				# Two files match, choose the more specific one
				# (the one with more path components)
				$old_depth = ($diff_name =~ tr/\///);
				$new_depth = (tr/\///);
				if ($old_depth == $new_depth)
				{
					die("ERROR: diff file contains ".
					    "ambiguous entries for ".
					    "$filename\n");
				}
				elsif ($new_depth > $old_depth)
				{
					$diff_name = $_;
				}
			}
			else
			{
				$diff_name = $_;
			}
		};
	}
	if ($diff_name)
	{
		# Get converted path
		if ($filename =~ /^(.*)$diff_name$/)
		{
			($common, $old_path, $new_path) =
				get_common_filename($filename,
					$1.$path_data->{$diff_name});
		}
		return ($diff_data->{$diff_name}, $old_path, $new_path);
	}
	else
	{
		return undef;
	}
}


#
# convert_paths(trace_data, path_conversion_data)
#
# Rename all paths in TRACE_DATA which show up in PATH_CONVERSION_DATA.
#

sub convert_paths($$)
{
	my ($trace_data, $path_conversion_data) = @_;
	my $filename;
	my $new_path;

	if (scalar(keys(%{$path_conversion_data})) == 0)
	{
		info("No path conversion data available.\n");
		return;
	}

	# Expand path conversion list
	foreach $filename (keys(%{$path_conversion_data}))
	{
		$new_path = $path_conversion_data->{$filename};
		while (($filename =~ s/^(.*)\/[^\/]+$/$1/) &&
		       ($new_path =~ s/^(.*)\/[^\/]+$/$1/) &&
		       ($filename ne $new_path))
		{
			$path_conversion_data->{$filename} = $new_path;
		}
	}

	# Adjust paths
	FILENAME: foreach $filename ($trace_data->files()) {

		# Find a path in our conversion table that matches, starting
		# with the longest path
		foreach (sort({length($b) <=> length($a)}
			      keys(%{$path_conversion_data})))
		{
			# Is this path a prefix of our filename?
			if (!($filename =~ /^$_(.*)$/))
			{
				next;
			}
			$new_path = $path_conversion_data->{$_}.$1;

			# Make sure not to overwrite an existing entry under
			# that path name
			my $file_data = $trace_data->data($filename);
			if ($trace_data->file_exists($new_path))
			{
				# Need to combine entries
				$trace_data->data($new_path)
				  ->merge($file_data, $filename);
			}
			else
			{
				# Simply rename entry
				$trace_data->insert($new_path, $file_data);
			}
			$filename ne $new_path
			  or die("about to remove data we just inserted");
			$trace_data->remove($filename);
			next FILENAME;
		}
		info("No conversion available for filename $filename\n");
	}
}

#
# sub adjust_fncdata(funcdata, testfncdata, sumfnccount)
#
# Remove function call count data from testfncdata and sumfnccount which
# is no longer present in funcdata.
#

sub adjust_fncdata($$$)
{
	my ($funcdata, $testfncdata, $sumfnccount) = @_;
	my $testname;
	my $func;
	my $f_found;
	my $f_hit;

	# Remove count data in testfncdata for functions which are no longer
	# in funcdata
	foreach $testname ($testfncdata->keylist()) {
		my $fnccount = $testfncdata->value($testname);
		# '$fnccount' is a CountData struct

		foreach $func ($fnccount->keylist()) {
			$fnccount->remove($func)
			  unless $funcdata->mapped($func);
		}
	}
	# Remove count data in sumfnccount for functions which are no longer
	# in funcdata
	foreach $func ($sumfnccount->keylist()) {
		$sumfnccount->remove($func)
		  unless $funcdata->mapped($func);
	}
}

#
#
# diff()
#

sub diff()
{
	my $readSourceFile = ReadCurrentSource->new();
	my $trace_data = TraceFile->load($diff, $readSourceFile);
	my %path_conversion_data;
	my $converted = 0;
	my $unchanged = 0;
	my @result;
	local *INFO_HANDLE;

	my ($diff_data, $path_data) = read_diff($ARGV[0]);

	foreach my $filename (sort($trace_data->files())) {

		# Find a diff section corresponding to this file
		my ($line_hash, $old_path, $new_path) =
			get_line_hash($filename, $diff_data, $path_data);
		if (!$line_hash)
		{
			# There's no diff section for this file
			$unchanged++;
			next;
		}
		$converted++;
		if ($old_path && $new_path && ($old_path ne $new_path))
		{
			$path_conversion_data{$old_path} = $new_path;
		}
		# Check for deleted files
		if (scalar(keys(%{$line_hash})) == 0)
		{
			info("Removing $filename\n");
			$trace_data->remove($filename);
			next;
		}
		info("Converting $filename\n");
		my $entry = $trace_data->data($filename);
		my ($testdata, $sumcount, $funcdata, $checkdata,
		    $testfncdata, $testbrdata, $sumbrcount) =
			$entry->get_info($entry);
		# Convert test data
		foreach my $testname ($testdata->keylist()) {

			my $ldata = $testdata->value($testname);
			# Adjust line numbers of line coverage data
			$testdata->replace($testname,
					   apply_diff($ldata, $line_hash));
			$ldata = $testdata->value($testname);
			if (scalar(keys(%$ldata)) == 0 ) {
			  $testdata->remove($testname);
			  $testfncdata->remove($testname);
			  $testbrdata->remove($testname);
			  next;
			}

			# Adjust line numbers of branch coverage data
			my $brdata = $testbrdata->value($testname);
			$testbrdata->replace($testname,
					     apply_diff($brdata, $line_hash));
		}
		# Rename test data to indicate conversion
		foreach my $testname ($testdata->keylist()) {

			# Skip testnames which already contain an extension
			if ($testname =~ /,[^,]+$/)
			{
				next;
			}
			my $diffname = $testname . ",diff";
			# Check for name conflict
			if ($testdata->mapped($diffname))
			{
				# Add counts
				$testdata->value($testname)->append(
					$testdata->value($diffname));
				$testdata->remove($diffname);
				# Add function call counts
				$testfncdata->value($testname)->append(
					$testfncdata->value($diffname));
				$testfncdata->remove($diffname);
				# Add branch counts
				$testbrdata->value($testname)->append(
					$testbrdata->value($diffname));
				$testbrdata->remove($diffname);
			}
			# Move test data to new testname
			$testdata->replace($diffname,
					   $testdata->value($testname));
			$testdata->remove($testname);
			# Move function call count data to new testname
			$testfncdata->replace($diffname,
				apply_diff_to_funcdata($testfncdata->value($testname), $line_hash));
			$testfncdata->remove($testname);
			# Move branch count data to new testname
			$testbrdata->replace($diffname,
				$testbrdata->value($testname));
			$testbrdata->remove($testname);
		}
		# Convert summary of test data
		$sumcount = apply_diff($sumcount, $line_hash);
		# Convert function data
		$funcdata = apply_diff_to_funcdata($funcdata, $line_hash);
		# Convert branch coverage data
		$sumbrcount = apply_diff($sumbrcount, $line_hash);
		# Update found/hit numbers
		# Convert checksum data
		$checkdata = apply_diff($checkdata, $line_hash);
		# Convert function call count data
		my ($f_found, $f_hit) = $funcdata->get_found_and_hit();
		my ($br_found, $br_hit) = $sumbrcount->get_found_and_hit();
		# Update found/hit numbers
		my ($found, $hit) = $sumcount->get_found_and_hit();
		if ($found > 0)
		{
			# Store converted entry
			$entry->set_info($testdata, $sumcount, $funcdata,
				       $checkdata, $testfncdata,
				       $testbrdata, $sumbrcount, $found, $hit,
				       $f_found, $f_hit, $br_found, $br_hit);
		}
		else
		{
			# Remove empty data set
			$trace_data->remove($filename);
		}
	}

	# Convert filenames as well if requested
	if ($convert_filenames)
	{
		convert_paths($trace_data, \%path_conversion_data);
	}

	info("$converted entr".($converted != 1 ? "ies" : "y")." converted, ".
	     "$unchanged entr".($unchanged != 1 ? "ies" : "y")." left ".
	     "unchanged.\n");

	# Write data
	if (!$data_stdout)
	{
		info("Writing data to $output_filename\n");
		if ($output_filename =~ /\.gz$/)
		{
			# Check for availability of GZIP tool
			system_no_output(1, "gzip" ,"-h")
				and die("ERROR: gzip command not available!\n");

			# Open compressed file
			open(INFO_HANDLE, "|-", "gzip -c >$output_filename")
				or die("ERROR: cannot start gzip to compress ".
				       "to file $output_filename!\n");
		} else {
			open(INFO_HANDLE, ">", $output_filename)
				or die("ERROR: cannot write to $output_filename!\n");
		}
		@result = $trace_data->write_info(*INFO_HANDLE);
		close(*INFO_HANDLE);
	}
	else
	{
		@result = $trace_data->write_info(*STDOUT);
	}

	return @result;
}

#
# summary()
#

sub summary()
{
	my $total = TraceFile->new();
	my $readSourceFile = ReadCurrentSource->new();
	my $ln_total_found = 0;
	my $ln_total_hit = 0;
	my $fn_total_found = 0;
	my $fn_total_hit = 0;
	my $br_total_found = 0;
	my $br_total_hit = 0;

	# Read and combine trace files
	foreach my $filename (@opt_summary) {
		my $current = TraceFile->load($filename);
		$total->append_tracefile($current);
	}
	# Calculate coverage data
	foreach my $filename ($total->files())
	{
		my $entry = $total->data($filename);
		my $ln_found;
		my $ln_hit;
		my $fn_found;
		my $fn_hit;
		my $br_found;
		my $br_hit;

		(undef, undef, undef, undef, undef, undef, undef,
		 $ln_found, $ln_hit, $fn_found, $fn_hit, $br_found, $br_hit)
		  = $entry->get_info();

		# Add to totals
		$ln_total_found += $ln_found;
		$ln_total_hit   += $ln_hit;
		$fn_total_found += $fn_found;
		$fn_total_hit   += $fn_hit;
		$br_total_found += $br_found;
		$br_total_hit   += $br_hit;
	}


	return ($ln_total_found, $ln_total_hit, $fn_total_found, $fn_total_hit,
		$br_total_found, $br_total_hit);
}

sub setup_gkv_sys()
{
	system_no_output(3, "mount", "-t", "debugfs", "nodev",
			 "/sys/kernel/debug");
}

sub setup_gkv_proc()
{
	if (system_no_output(3, "modprobe", "gcov_proc")) {
		system_no_output(3, "modprobe", "gcov_prof");
	}
}

sub check_gkv_sys($)
{
	my ($dir) = @_;

	if (-e "$dir/reset") {
		return 1;
	}
	return 0;
}

sub check_gkv_proc($)
{
	my ($dir) = @_;

	if (-e "$dir/vmlinux") {
		return 1;
	}
	return 0;
}

sub setup_gkv()
{
	my $dir;
	my $sys_dir = "/sys/kernel/debug/gcov";
	my $proc_dir = "/proc/gcov";
	my @todo;

	if (!defined($gcov_dir)) {
		info("Auto-detecting gcov kernel support.\n");
		@todo = ( "cs", "cp", "ss", "cs", "sp", "cp" );
	} elsif ($gcov_dir =~ /proc/) {
		info("Checking gcov kernel support at $gcov_dir ".
		     "(user-specified).\n");
		@todo = ( "cp", "sp", "cp", "cs", "ss", "cs");
	} else {
		info("Checking gcov kernel support at $gcov_dir ".
		     "(user-specified).\n");
		@todo = ( "cs", "ss", "cs", "cp", "sp", "cp", );
	}
	foreach (@todo) {
		if ($_ eq "cs") {
			# Check /sys
			$dir = defined($gcov_dir) ? $gcov_dir : $sys_dir;
			if (check_gkv_sys($dir)) {
				info("Found ".$GKV_NAME[$GKV_SYS]." gcov ".
				     "kernel support at $dir\n");
				return ($GKV_SYS, $dir);
			}
		} elsif ($_ eq "cp") {
			# Check /proc
			$dir = defined($gcov_dir) ? $gcov_dir : $proc_dir;
			if (check_gkv_proc($dir)) {
				info("Found ".$GKV_NAME[$GKV_PROC]." gcov ".
				     "kernel support at $dir\n");
				return ($GKV_PROC, $dir);
			}
		} elsif ($_ eq "ss") {
			# Setup /sys
			setup_gkv_sys();
		} elsif ($_ eq "sp") {
			# Setup /proc
			setup_gkv_proc();
		}
	}
	if (defined($gcov_dir)) {
		die("ERROR: could not find gcov kernel data at $gcov_dir\n");
	} else {
		die("ERROR: no gcov kernel data found\n");
	}
}


#
# print_overall_rate(ln_do, ln_found, ln_hit, fn_do, fn_found, fn_hit, br_do
#		    br_found, br_hit)
#
# Print overall coverage rates for the specified coverage types.
#

sub print_overall_rate($$$$$$$$$)
{
	my ($ln_do, $ln_found, $ln_hit, $fn_do, $fn_found, $fn_hit,
	    $br_do, $br_found, $br_hit) = @_;

	info("Summary coverage rate:\n");
	info("  lines......: %s\n",
	     get_overall_line($ln_found, $ln_hit, "line"))
		if ($ln_do);
	info("  functions..: %s\n",
	     get_overall_line($fn_found, $fn_hit, "function"))
		if ($fn_do);
	info("  branches...: %s\n",
	     get_overall_line($br_found, $br_hit, "branch"))
		if ($br_do);
}
